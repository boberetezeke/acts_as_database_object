
class ActiveRecord::Base #:nodoc:

  # These extensions make models taggable. This file is automatically generated and required by your app if you run the tagging generator included with has_many_polymorphs.
  module TaggingExtensions
    
    # Add tags to <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    #
    # We need to avoid name conflicts with the built-in ActiveRecord association methods, thus the underscores.
    def _add_tags incoming
      taggable?(true)
      tag_cast_to_string(incoming).each do |tag_name|
        begin
          tag = ObjectDatabaseTag.find_or_create_by_name(tag_name)
          raise ObjectDatabaseTag::Error, "tag could not be saved: #{tag_name}" if tag.new_record?
          tag.taggables << self
        rescue ActiveRecord::StatementInvalid => e
          raise unless e.to_s =~ /duplicate/i
        end
      end
    end
  
    # Removes tags from <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.  
    def _remove_tags outgoing
      taggable?(true)
      outgoing = tag_cast_to_string(outgoing)
     
      tags.delete(*(tags.select do |tag|
        outgoing.include? tag.name    
      end))
      end

   # Returns the tags on <tt>self</tt> as a string.
    def tag_list
      # Redefined later to avoid an RDoc parse error.
    end
  
    # Replace the existing tags on <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    def tag_with list    
      #:stopdoc:
      taggable?(true)
      list = tag_cast_to_string(list)
             
      # Transactions may not be ideal for you here; be aware.
      ObjectDatabaseTag.transaction do 
        current = tags.map(&:name)
        _add_tags(list - current)
        _remove_tags(current - list)
      end
      
      self
      #:startdoc:
    end

   # Returns the tags on <tt>self</tt> as a string.
    def tag_list #:nodoc:
      #:stopdoc:
      taggable?(true)
      tags.reload
      tags.to_s
      #:startdoc:
    end

    def tag_list=(list)
    	tag_with(list)
    end

    def tags
    	self.object_database_tags
    end
    
    private 
    
    def tag_cast_to_string obj #:nodoc:
      case obj
        when Array
          obj.map! do |item|
            case item
              when /^\d+$/, Fixnum then ObjectDatabaseTag.find(item).name # This will be slow if you use ids a lot.
              when ObjectDatabaseTag then item.name
              when String then item
              else
                raise "Invalid type"
            end
          end              
        when String
          obj = obj.split(ObjectDatabaseTag::DELIMITER).map do |tag_name| 
            tag_name.strip.squeeze(" ")
          end
        else
          raise "Invalid object of class #{obj.class} as tagging method parameter"
      end.flatten.compact.map(&:downcase).uniq
    end 
  
    # Check if a model is in the :taggables target list. The alternative to this check is to explicitly include a TaggingMethods module (which you would create) in each target model.  
    def taggable?(should_raise = false) #:nodoc:
      unless flag = respond_to?(:object_database_tags)
        raise "#{self.class} is not a taggable model" if should_raise
      end
      flag
    end

  end
  
  module TaggingFinders

    # Find all the objects tagged with the supplied list of tags
    # 
    # Usage : Model.tagged_with("ruby")
    #         Model.tagged_with("hello", "world")
    #         Model.tagged_with("hello", "world", :limit => 10)
    #
    # XXX This query strategy is not performant, and needs to be rewritten as an inverted join or a series of unions
    # 
    def tagged_with(*tag_list)
      #puts "sql = '#{sql}'"
      
      find_by_sql(tagged_with_sql(*tag_list))
    end

    def tagged_with_count(*tag_list)
    	num_counted(find_by_sql(count_of_sql(tagged_with_sql(*tag_list))))
    end

    def is_tagged(options={})
      find_by_sql(tagged_at_all_sql(true, options))
	 end

	 def is_tagged_count(options={})
      num_counted(find_by_sql(count_of_sql(tagged_at_all_sql(true, options))))
	 end
	
    def is_not_tagged(options={})
      find_by_sql(tagged_at_all_sql(false, options))
	 end

	 def is_not_tagged_count(options={})
      num_counted(find_by_sql(count_of_sql(tagged_at_all_sql(false, options))))
	 end

    def tagged_with_sql(*tag_list)
      options = tag_list.last.is_a?(Hash) ? tag_list.pop : {}
      tag_list = parse_tags(tag_list)
      
      scope = scope(:find)
      options[:select] ||= "#{table_name}.*"
      options[:from] ||= "#{table_name}, object_database_tags, object_database_taggings"
      
      sql  = "SELECT #{(scope && scope[:select]) || options[:select]} "
      sql << "FROM #{(scope && scope[:from]) || options[:from]} "

      add_joins!(sql, options, scope)
      
      sql << "WHERE #{table_name}.#{primary_key} = object_database_taggings.taggable_id "
      sql << "AND object_database_taggings.taggable_type = '#{ActiveRecord::Base.send(:class_name_of_active_record_descendant, self).to_s}' "
      sql << "AND object_database_taggings.object_database_tag_id = object_database_tags.id "
      
      tag_list_condition = tag_list.map {|name| "'#{name}'"}.join(", ")
      
      sql << "AND (object_database_tags.name IN (#{sanitize_sql(tag_list_condition)})) "
      sql << "AND #{sanitize_sql(options[:conditions])} " if options[:conditions]
      
      columns = column_names.map do |column| 
        "#{table_name}.#{column}"
      end.join(", ")
      
      sql << "GROUP BY #{columns} "
      sql << "HAVING COUNT(object_database_taggings.object_database_tag_id) = #{tag_list.size}"
      
      add_order!(sql, options[:order], scope)
      add_limit!(sql, options, scope)
      add_lock!(sql, options, scope)
		#puts "sql = #{sql}"
      return sql
    end

    def tagged_at_all_sql(is_tagged, options={})
puts "options = #{options.inspect}"
      scope = scope(:find)
      options[:select] ||= "#{table_name}.*"
      options[:from] ||= "#{table_name}"
      options[:include] ||= "object_database_taggings"
      
      sql  = "SELECT distinct #{(scope && scope[:select]) || options[:select]} "
      sql << "FROM #{(scope && scope[:from]) || options[:from]} "
      sql << "LEFT OUTER JOIN object_database_taggings ON #{table_name}.id = object_database_taggings.taggable_id"

      add_joins!(sql, options, scope)
      
      sql << "WHERE object_database_taggings.taggable_id is " + (is_tagged ? "not " : "" ) + "null "
      sql << "AND object_database_taggings.taggable_type = '#{ActiveRecord::Base.send(:class_name_of_active_record_descendant, self).to_s}' "
      #sql << "AND object_database_taggings.object_database_tag_id = object_database_tags.id "
            
      sql << "AND #{sanitize_sql(options[:conditions])} " if options[:conditions]
      
      add_order!(sql, options[:order], scope)
      add_limit!(sql, options, scope)
      add_lock!(sql, options, scope)
		#puts "sql = #{sql}"
      return sql
    end

	 def count_of_sql(sql)
	 	"select count(*) from (#{sql}) as tagged_objects"
	 end

	 def num_counted(sql_result)
puts "sql_result = #{sql_result.inspect}"
	 	sql_result.first["count(*)"].to_i
	 end
    
    def parse_tags(tags)
      return [] if tags.blank?
      tags = Array(tags).first
      tags = tags.respond_to?(:flatten) ? tags.flatten : tags.split(ObjectDatabaseTag::DELIMITER)
      tags.map { |tag| tag.strip.squeeze(" ") }.flatten.compact.map(&:downcase).uniq
    end
    
  end

  include TaggingExtensions
  extend  TaggingFinders
end
